- revisit instantiateL and instantiateR algo
- product types:
    - think out: 
        - Product type literal
        - How to construct a anonymous product type (maybe something akin to a record)
        - How to construct a named type 
        - How would we handle structural and nominal typing 
            - proposition: 
            ```elixir
                defmodule User do
                    defstruct name: "John", age: 27
                end
                a = %User{}
                [:__struct__, :age, :name] = Map.keys a 
             ```
             Nominal types could be implemented using the special :__struct__ tag in a structural type

- remove 'case _ =>' matches
- allow annotating only function parameter
    - maybe ELambda could accept a PlainArg(String) or AnnotatedArg(String, Type) ?
    - alternative: transform the annotations of args to annotation of function type at creating Function expression
- struct field access expression (dot ?)
- non-unary functions
- think about some better way to test errors than matching on their type like in the "fail on shadowed variable names" test 
- if expression 
- NOT_IMPLEMENTED expression, akin to ??? in scala
- unify apis that take context as an argument - either all take it as a first arg, or the last
- maybe its possible to abstract arity check
- add primitive list type 
- add void primitive type